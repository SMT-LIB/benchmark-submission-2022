
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status unsat)
; benchmark generated from python API
(declare-fun b__3 () Int)
(declare-fun b__2 () Int)
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun start () (Array Int Int))
(assert
 (and (distinct b__0 b__1 b__2 b__3) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 3))
(assert
 (<= v__0 3))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 3))
(assert
 (<= v__1 3))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 3))
(assert
 (<= v__2 3))
(assert
 (let ((?x224 (* b__0 1)))
 (let ((?x232 (+ v__2 ?x224)))
 (let ((?x244 (* b__0 3)))
 (let ((?x245 (+ v__1 ?x244)))
 (let ((?x227 (* b__0 2)))
 (let ((?x228 (+ v__0 ?x227)))
 (let ((?x234 (store start ?x228 (+ (select start ?x228) 1))))
 (let ((?x222 (store ?x234 ?x245 (+ (select ?x234 ?x245) 1))))
 (let ((?x241 (store ?x222 ?x232 (+ (select ?x222 ?x232) 1))))
 (let ((?x223 (+ w__2 ?x244)))
 (let ((?x235 (+ w__1 ?x227)))
 (let ((?x225 (+ w__0 ?x224)))
 (let ((?x226 (store start ?x225 (+ (select start ?x225) 1))))
 (let ((?x243 (store ?x226 ?x235 (+ (select ?x226 ?x235) 1))))
 (let ((?x231 (store ?x243 ?x223 (+ (select ?x243 ?x223) 1))))
 (= ?x231 ?x241)))))))))))))))))
(assert
 (let ((?x156 (* b__1 1)))
 (let ((?x159 (+ v__2 ?x156)))
 (let ((?x162 (* b__1 3)))
 (let ((?x147 (+ v__1 ?x162)))
 (let ((?x98 (* b__1 2)))
 (let ((?x145 (+ v__0 ?x98)))
 (let ((?x142 (store start ?x145 (+ (select start ?x145) 1))))
 (let ((?x82 (store ?x142 ?x147 (+ (select ?x142 ?x147) 1))))
 (let ((?x97 (store ?x82 ?x159 (+ (select ?x82 ?x159) 1))))
 (let ((?x158 (+ w__2 ?x162)))
 (let ((?x143 (+ w__1 ?x98)))
 (let ((?x49 (+ w__0 ?x156)))
 (let ((?x138 (store start ?x49 (+ (select start ?x49) 1))))
 (let ((?x101 (store ?x138 ?x143 (+ (select ?x138 ?x143) 1))))
 (let ((?x102 (store ?x101 ?x158 (+ (select ?x101 ?x158) 1))))
 (= ?x102 ?x97)))))))))))))))))
(assert
 (let ((?x265 (* b__2 1)))
 (let ((?x202 (+ v__2 ?x265)))
 (let ((?x197 (* b__2 3)))
 (let ((?x192 (+ v__1 ?x197)))
 (let ((?x270 (* b__2 2)))
 (let ((?x271 (+ v__0 ?x270)))
 (let ((?x45 (store start ?x271 (+ (select start ?x271) 1))))
 (let ((?x195 (store ?x45 ?x192 (+ (select ?x45 ?x192) 1))))
 (let ((?x205 (store ?x195 ?x202 (+ (select ?x195 ?x202) 1))))
 (let ((?x198 (+ w__2 ?x197)))
 (let ((?x44 (+ w__1 ?x270)))
 (let ((?x266 (+ w__0 ?x265)))
 (let ((?x269 (store start ?x266 (+ (select start ?x266) 1))))
 (let ((?x196 (store ?x269 ?x44 (+ (select ?x269 ?x44) 1))))
 (let ((?x201 (store ?x196 ?x198 (+ (select ?x196 ?x198) 1))))
 (= ?x201 ?x205)))))))))))))))))
(assert
 (let ((?x77 (* b__3 1)))
 (let ((?x209 (+ v__2 ?x77)))
 (let ((?x74 (* b__3 3)))
 (let ((?x167 (+ v__1 ?x74)))
 (let ((?x62 (* b__3 2)))
 (let ((?x61 (+ v__0 ?x62)))
 (let ((?x249 (store start ?x61 (+ (select start ?x61) 1))))
 (let ((?x66 (store ?x249 ?x167 (+ (select ?x249 ?x167) 1))))
 (let ((?x212 (store ?x66 ?x209 (+ (select ?x66 ?x209) 1))))
 (let ((?x65 (+ w__2 ?x74)))
 (let ((?x250 (+ w__1 ?x62)))
 (let ((?x72 (+ w__0 ?x77)))
 (let ((?x63 (store start ?x72 (+ (select start ?x72) 1))))
 (let ((?x255 (store ?x63 ?x250 (+ (select ?x63 ?x250) 1))))
 (let ((?x208 (store ?x255 ?x65 (+ (select ?x255 ?x65) 1))))
 (= ?x208 ?x212)))))))))))))))))
(assert
 (not (and (= w__1 v__0) (= w__2 v__1) (= w__0 v__2))))
(check-sat)
(exit)
