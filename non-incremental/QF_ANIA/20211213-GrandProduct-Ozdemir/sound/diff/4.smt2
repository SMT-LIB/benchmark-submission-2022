
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status unsat)
; benchmark generated from python API
(declare-fun b__4 () Int)
(declare-fun b__3 () Int)
(declare-fun b__2 () Int)
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun w__3 () Int)
(declare-fun v__3 () Int)
(declare-fun start () (Array Int Int))
(assert
 (and (distinct b__0 b__1 b__2 b__3 b__4) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 4))
(assert
 (<= v__0 4))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 4))
(assert
 (<= v__1 4))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 4))
(assert
 (<= v__2 4))
(assert
 (>= w__3 0))
(assert
 (>= v__3 0))
(assert
 (<= w__3 4))
(assert
 (<= v__3 4))
(assert
 (let ((?x360 (* b__0 1)))
 (let ((?x377 (+ v__3 ?x360)))
 (let ((?x358 (* b__0 4)))
 (let ((?x359 (+ v__2 ?x358)))
 (let ((?x379 (* b__0 3)))
 (let ((?x380 (+ v__1 ?x379)))
 (let ((?x363 (* b__0 2)))
 (let ((?x364 (+ v__0 ?x363)))
 (let ((?x369 (store start ?x364 (+ (select start ?x364) 1))))
 (let ((?x388 (store ?x369 ?x380 (+ (select ?x369 ?x380) 1))))
 (let ((?x367 (store ?x388 ?x359 (+ (select ?x388 ?x359) 1))))
 (let ((?x386 (store ?x367 ?x377 (+ (select ?x367 ?x377) 1))))
 (let ((?x368 (+ w__3 ?x358)))
 (let ((?x389 (+ w__2 ?x379)))
 (let ((?x370 (+ w__1 ?x363)))
 (let ((?x361 (+ w__0 ?x360)))
 (let ((?x362 (store start ?x361 (+ (select start ?x361) 1))))
 (let ((?x373 (store ?x362 ?x370 (+ (select ?x362 ?x370) 1))))
 (let ((?x357 (store ?x373 ?x389 (+ (select ?x373 ?x389) 1))))
 (let ((?x376 (store ?x357 ?x368 (+ (select ?x357 ?x368) 1))))
 (= ?x376 ?x386))))))))))))))))))))))
(assert
 (let ((?x163 (* b__1 1)))
 (let ((?x100 (+ v__3 ?x163)))
 (let ((?x269 (* b__1 4)))
 (let ((?x85 (+ v__2 ?x269)))
 (let ((?x102 (* b__1 3)))
 (let ((?x144 (+ v__1 ?x102)))
 (let ((?x30 (* b__1 2)))
 (let ((?x29 (+ v__0 ?x30)))
 (let ((?x221 (store start ?x29 (+ (select start ?x29) 1))))
 (let ((?x138 (store ?x221 ?x144 (+ (select ?x221 ?x144) 1))))
 (let ((?x272 (store ?x138 ?x85 (+ (select ?x138 ?x85) 1))))
 (let ((?x156 (store ?x272 ?x100 (+ (select ?x272 ?x100) 1))))
 (let ((?x271 (+ w__3 ?x269)))
 (let ((?x137 (+ w__2 ?x102)))
 (let ((?x222 (+ w__1 ?x30)))
 (let ((?x89 (+ w__0 ?x163)))
 (let ((?x16 (store start ?x89 (+ (select start ?x89) 1))))
 (let ((?x99 (store ?x16 ?x222 (+ (select ?x16 ?x222) 1))))
 (let ((?x203 (store ?x99 ?x137 (+ (select ?x99 ?x137) 1))))
 (let ((?x140 (store ?x203 ?x271 (+ (select ?x203 ?x271) 1))))
 (= ?x140 ?x156))))))))))))))))))))))
(assert
 (let ((?x153 (* b__2 1)))
 (let ((?x268 (+ v__3 ?x153)))
 (let ((?x241 (* b__2 4)))
 (let ((?x172 (+ v__2 ?x241)))
 (let ((?x170 (* b__2 3)))
 (let ((?x171 (+ v__1 ?x170)))
 (let ((?x224 (* b__2 2)))
 (let ((?x236 (+ v__0 ?x224)))
 (let ((?x149 (store start ?x236 (+ (select start ?x236) 1))))
 (let ((?x103 (store ?x149 ?x171 (+ (select ?x149 ?x171) 1))))
 (let ((?x273 (store ?x103 ?x172 (+ (select ?x103 ?x172) 1))))
 (let ((?x264 (store ?x273 ?x268 (+ (select ?x273 ?x268) 1))))
 (let ((?x185 (+ w__3 ?x241)))
 (let ((?x121 (+ w__2 ?x170)))
 (let ((?x113 (+ w__1 ?x224)))
 (let ((?x35 (+ w__0 ?x153)))
 (let ((?x142 (store start ?x35 (+ (select start ?x35) 1))))
 (let ((?x186 (store ?x142 ?x113 (+ (select ?x142 ?x113) 1))))
 (let ((?x150 (store ?x186 ?x121 (+ (select ?x186 ?x121) 1))))
 (let ((?x270 (store ?x150 ?x185 (+ (select ?x150 ?x185) 1))))
 (= ?x270 ?x264))))))))))))))))))))))
(assert
 (let ((?x345 (* b__3 1)))
 (let ((?x130 (+ v__3 ?x345)))
 (let ((?x72 (* b__3 4)))
 (let ((?x41 (+ v__2 ?x72)))
 (let ((?x13 (* b__3 3)))
 (let ((?x14 (+ v__1 ?x13)))
 (let ((?x349 (* b__3 2)))
 (let ((?x319 (+ v__0 ?x349)))
 (let ((?x322 (store start ?x319 (+ (select start ?x319) 1))))
 (let ((?x116 (store ?x322 ?x14 (+ (select ?x322 ?x14) 1))))
 (let ((?x230 (store ?x116 ?x41 (+ (select ?x116 ?x41) 1))))
 (let ((?x198 (store ?x230 ?x130 (+ (select ?x230 ?x130) 1))))
 (let ((?x25 (+ w__3 ?x72)))
 (let ((?x38 (+ w__2 ?x13)))
 (let ((?x324 (+ w__1 ?x349)))
 (let ((?x333 (+ w__0 ?x345)))
 (let ((?x348 (store start ?x333 (+ (select start ?x333) 1))))
 (let ((?x327 (store ?x348 ?x324 (+ (select ?x348 ?x324) 1))))
 (let ((?x76 (store ?x327 ?x38 (+ (select ?x327 ?x38) 1))))
 (let ((?x219 (store ?x76 ?x25 (+ (select ?x76 ?x25) 1))))
 (= ?x219 ?x198))))))))))))))))))))))
(assert
 (let ((?x411 (* b__4 1)))
 (let ((?x162 (+ v__3 ?x411)))
 (let ((?x206 (* b__4 4)))
 (let ((?x255 (+ v__2 ?x206)))
 (let ((?x19 (* b__4 3)))
 (let ((?x168 (+ v__1 ?x19)))
 (let ((?x417 (* b__4 2)))
 (let ((?x418 (+ v__0 ?x417)))
 (let ((?x422 (store start ?x418 (+ (select start ?x418) 1))))
 (let ((?x123 (store ?x422 ?x168 (+ (select ?x422 ?x168) 1))))
 (let ((?x209 (store ?x123 ?x255 (+ (select ?x123 ?x255) 1))))
 (let ((?x94 (store ?x209 ?x162 (+ (select ?x209 ?x162) 1))))
 (let ((?x77 (+ w__3 ?x206)))
 (let ((?x330 (+ w__2 ?x19)))
 (let ((?x177 (+ w__1 ?x417)))
 (let ((?x412 (+ w__0 ?x411)))
 (let ((?x416 (store start ?x412 (+ (select start ?x412) 1))))
 (let ((?x17 (store ?x416 ?x177 (+ (select ?x416 ?x177) 1))))
 (let ((?x254 (store ?x17 ?x330 (+ (select ?x17 ?x330) 1))))
 (let ((?x158 (store ?x254 ?x77 (+ (select ?x254 ?x77) 1))))
 (= ?x158 ?x94))))))))))))))))))))))
(assert
 (let (($x275 (and (= w__1 v__0) (= w__2 v__1) (= w__3 v__2) (= w__0 v__3))))
 (not $x275)))
(check-sat)
(exit)
