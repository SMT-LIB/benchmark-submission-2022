
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status unsat)
; benchmark generated from python API
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun w__3 () Int)
(declare-fun v__3 () Int)
(declare-fun b__4 () Int)
(declare-fun b__3 () Int)
(declare-fun b__2 () Int)
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun start () (Array Int Int))
(assert
 (= v__0 w__0))
(assert
 (= v__1 w__1))
(assert
 (= v__2 w__2))
(assert
 (= v__3 w__3))
(assert
 (and (distinct b__0 b__1 b__2 b__3 b__4) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 4))
(assert
 (<= v__0 4))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 4))
(assert
 (<= v__1 4))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 4))
(assert
 (<= v__2 4))
(assert
 (>= w__3 0))
(assert
 (>= v__3 0))
(assert
 (<= w__3 4))
(assert
 (<= v__3 4))
(assert
 (let ((?x36 (* b__0 1)))
 (let ((?x224 (+ v__3 ?x36)))
 (let ((?x69 (* b__0 4)))
 (let ((?x35 (+ v__2 ?x69)))
 (let ((?x233 (* b__0 3)))
 (let ((?x238 (+ v__1 ?x233)))
 (let ((?x23 (* b__0 2)))
 (let ((?x112 (+ v__0 ?x23)))
 (let ((?x86 (store start ?x112 (+ (select start ?x112) 1))))
 (let ((?x153 (store ?x86 ?x238 (+ (select ?x86 ?x238) 1))))
 (let ((?x142 (store ?x153 ?x35 (+ (select ?x153 ?x35) 1))))
 (let ((?x124 (store ?x142 ?x224 (+ (select ?x142 ?x224) 1))))
 (let ((?x147 (+ w__3 ?x69)))
 (let ((?x243 (+ w__2 ?x233)))
 (let ((?x96 (+ w__1 ?x23)))
 (let ((?x31 (+ w__0 ?x36)))
 (let ((?x122 (store start ?x31 (+ (select start ?x31) 1))))
 (let ((?x160 (store ?x122 ?x96 (+ (select ?x122 ?x96) 1))))
 (let ((?x59 (store ?x160 ?x243 (+ (select ?x160 ?x243) 1))))
 (let ((?x148 (store ?x59 ?x147 (+ (select ?x59 ?x147) 1))))
 (= ?x148 ?x124))))))))))))))))))))))
(assert
 (let ((?x221 (* b__1 1)))
 (let ((?x201 (+ v__3 ?x221)))
 (let ((?x85 (* b__1 4)))
 (let ((?x192 (+ v__2 ?x85)))
 (let ((?x137 (* b__1 3)))
 (let ((?x48 (+ v__1 ?x137)))
 (let ((?x102 (* b__1 2)))
 (let ((?x145 (+ v__0 ?x102)))
 (let ((?x100 (store start ?x145 (+ (select start ?x145) 1))))
 (let ((?x214 (store ?x100 ?x48 (+ (select ?x100 ?x48) 1))))
 (let ((?x193 (store ?x214 ?x192 (+ (select ?x214 ?x192) 1))))
 (let ((?x32 (store ?x193 ?x201 (+ (select ?x193 ?x201) 1))))
 (let ((?x47 (+ w__3 ?x85)))
 (let ((?x205 (+ w__2 ?x137)))
 (let ((?x144 (+ w__1 ?x102)))
 (let ((?x222 (+ w__0 ?x221)))
 (let ((?x99 (store start ?x222 (+ (select start ?x222) 1))))
 (let ((?x138 (store ?x99 ?x144 (+ (select ?x99 ?x144) 1))))
 (let ((?x269 (store ?x138 ?x205 (+ (select ?x138 ?x205) 1))))
 (let ((?x271 (store ?x269 ?x47 (+ (select ?x269 ?x47) 1))))
 (= ?x271 ?x32))))))))))))))))))))))
(assert
 (let ((?x146 (* b__2 1)))
 (let ((?x16 (+ v__3 ?x146)))
 (let ((?x251 (* b__2 4)))
 (let ((?x163 (+ v__2 ?x251)))
 (let ((?x257 (* b__2 3)))
 (let ((?x55 (+ v__1 ?x257)))
 (let ((?x191 (* b__2 2)))
 (let ((?x105 (+ v__0 ?x191)))
 (let ((?x90 (store start ?x105 (+ (select start ?x105) 1))))
 (let ((?x132 (store ?x90 ?x55 (+ (select ?x90 ?x55) 1))))
 (let ((?x56 (store ?x132 ?x163 (+ (select ?x132 ?x163) 1))))
 (let ((?x260 (store ?x56 ?x16 (+ (select ?x56 ?x16) 1))))
 (let ((?x164 (+ w__3 ?x251)))
 (let ((?x109 (+ w__2 ?x257)))
 (let ((?x46 (+ w__1 ?x191)))
 (let ((?x267 (+ w__0 ?x146)))
 (let ((?x213 (store start ?x267 (+ (select start ?x267) 1))))
 (let ((?x217 (store ?x213 ?x46 (+ (select ?x213 ?x46) 1))))
 (let ((?x20 (store ?x217 ?x109 (+ (select ?x217 ?x109) 1))))
 (let ((?x22 (store ?x20 ?x164 (+ (select ?x20 ?x164) 1))))
 (= ?x22 ?x260))))))))))))))))))))))
(assert
 (let ((?x282 (* b__3 1)))
 (let ((?x314 (+ v__3 ?x282)))
 (let ((?x305 (* b__3 4)))
 (let ((?x306 (+ v__2 ?x305)))
 (let ((?x296 (* b__3 3)))
 (let ((?x297 (+ v__1 ?x296)))
 (let ((?x287 (* b__3 2)))
 (let ((?x288 (+ v__0 ?x287)))
 (let ((?x291 (store start ?x288 (+ (select start ?x288) 1))))
 (let ((?x300 (store ?x291 ?x297 (+ (select ?x291 ?x297) 1))))
 (let ((?x309 (store ?x300 ?x306 (+ (select ?x300 ?x306) 1))))
 (let ((?x317 (store ?x309 ?x314 (+ (select ?x309 ?x314) 1))))
 (let ((?x310 (+ w__3 ?x305)))
 (let ((?x301 (+ w__2 ?x296)))
 (let ((?x292 (+ w__1 ?x287)))
 (let ((?x283 (+ w__0 ?x282)))
 (let ((?x286 (store start ?x283 (+ (select start ?x283) 1))))
 (let ((?x295 (store ?x286 ?x292 (+ (select ?x286 ?x292) 1))))
 (let ((?x304 (store ?x295 ?x301 (+ (select ?x295 ?x301) 1))))
 (let ((?x313 (store ?x304 ?x310 (+ (select ?x304 ?x310) 1))))
 (= ?x313 ?x317))))))))))))))))))))))
(assert
 (let ((?x355 (* b__4 1)))
 (let ((?x387 (+ v__3 ?x355)))
 (let ((?x378 (* b__4 4)))
 (let ((?x379 (+ v__2 ?x378)))
 (let ((?x369 (* b__4 3)))
 (let ((?x370 (+ v__1 ?x369)))
 (let ((?x360 (* b__4 2)))
 (let ((?x361 (+ v__0 ?x360)))
 (let ((?x364 (store start ?x361 (+ (select start ?x361) 1))))
 (let ((?x373 (store ?x364 ?x370 (+ (select ?x364 ?x370) 1))))
 (let ((?x382 (store ?x373 ?x379 (+ (select ?x373 ?x379) 1))))
 (let ((?x390 (store ?x382 ?x387 (+ (select ?x382 ?x387) 1))))
 (let ((?x383 (+ w__3 ?x378)))
 (let ((?x374 (+ w__2 ?x369)))
 (let ((?x365 (+ w__1 ?x360)))
 (let ((?x356 (+ w__0 ?x355)))
 (let ((?x359 (store start ?x356 (+ (select start ?x356) 1))))
 (let ((?x368 (store ?x359 ?x365 (+ (select ?x359 ?x365) 1))))
 (let ((?x377 (store ?x368 ?x374 (+ (select ?x368 ?x374) 1))))
 (let ((?x386 (store ?x377 ?x383 (+ (select ?x377 ?x383) 1))))
 (= ?x386 ?x390))))))))))))))))))))))
(assert
 (let (($x432 (and (= w__1 v__0) (= w__2 v__1) (= w__3 v__2) (= w__0 v__3))))
 (not $x432)))
(check-sat)
(exit)
