
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status sat)
; benchmark generated from python API
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun w__3 () Int)
(declare-fun v__3 () Int)
(declare-fun w__4 () Int)
(declare-fun v__4 () Int)
(declare-fun start () (Array Int Int))
(assert
 (and (distinct b__0 b__1) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 5))
(assert
 (<= v__0 5))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 5))
(assert
 (<= v__1 5))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 5))
(assert
 (<= v__2 5))
(assert
 (>= w__3 0))
(assert
 (>= v__3 0))
(assert
 (<= w__3 5))
(assert
 (<= v__3 5))
(assert
 (>= w__4 0))
(assert
 (>= v__4 0))
(assert
 (<= w__4 5))
(assert
 (<= v__4 5))
(assert
 (let ((?x143 (* b__0 1)))
 (let ((?x357 (+ v__4 ?x143)))
 (let ((?x100 (* b__0 5)))
 (let ((?x48 (+ v__3 ?x100)))
 (let ((?x381 (* b__0 4)))
 (let ((?x382 (+ v__2 ?x381)))
 (let ((?x370 (* b__0 3)))
 (let ((?x371 (+ v__1 ?x370)))
 (let ((?x85 (* b__0 2)))
 (let ((?x47 (+ v__0 ?x85)))
 (let ((?x49 (store start ?x47 (+ (select start ?x47) 1))))
 (let ((?x379 (store ?x49 ?x371 (+ (select ?x49 ?x371) 1))))
 (let ((?x261 (store ?x379 ?x382 (+ (select ?x379 ?x382) 1))))
 (let ((?x362 (store ?x261 ?x48 (+ (select ?x261 ?x48) 1))))
 (let ((?x369 (store ?x362 ?x357 (+ (select ?x362 ?x357) 1))))
 (let ((?x363 (+ w__4 ?x100)))
 (let ((?x221 (+ w__3 ?x381)))
 (let ((?x368 (+ w__2 ?x370)))
 (let ((?x156 (+ w__1 ?x85)))
 (let ((?x98 (+ w__0 ?x143)))
 (let ((?x138 (store start ?x98 (+ (select start ?x98) 1))))
 (let ((?x361 (store ?x138 ?x156 (+ (select ?x138 ?x156) 1))))
 (let ((?x376 (store ?x361 ?x368 (+ (select ?x361 ?x368) 1))))
 (let ((?x272 (store ?x376 ?x221 (+ (select ?x376 ?x221) 1))))
 (let ((?x356 (store ?x272 ?x363 (+ (select ?x272 ?x363) 1))))
 (= ?x356 ?x369)))))))))))))))))))))))))))
(assert
 (let ((?x187 (* b__1 1)))
 (let ((?x165 (+ v__4 ?x187)))
 (let ((?x311 (* b__1 5)))
 (let ((?x273 (+ v__3 ?x311)))
 (let ((?x299 (* b__1 4)))
 (let ((?x298 (+ v__2 ?x299)))
 (let ((?x365 (* b__1 3)))
 (let ((?x366 (+ v__1 ?x365)))
 (let ((?x124 (* b__1 2)))
 (let ((?x149 (+ v__0 ?x124)))
 (let ((?x78 (store start ?x149 (+ (select start ?x149) 1))))
 (let ((?x384 (store ?x78 ?x366 (+ (select ?x78 ?x366) 1))))
 (let ((?x290 (store ?x384 ?x298 (+ (select ?x384 ?x298) 1))))
 (let ((?x262 (store ?x290 ?x273 (+ (select ?x290 ?x273) 1))))
 (let ((?x247 (store ?x262 ?x165 (+ (select ?x262 ?x165) 1))))
 (let ((?x263 (+ w__4 ?x311)))
 (let ((?x289 (+ w__3 ?x299)))
 (let ((?x385 (+ w__2 ?x365)))
 (let ((?x103 (+ w__1 ?x124)))
 (let ((?x43 (+ w__0 ?x187)))
 (let ((?x237 (store start ?x43 (+ (select start ?x43) 1))))
 (let ((?x218 (store ?x237 ?x103 (+ (select ?x237 ?x103) 1))))
 (let ((?x300 (store ?x218 ?x385 (+ (select ?x218 ?x385) 1))))
 (let ((?x312 (store ?x300 ?x289 (+ (select ?x300 ?x289) 1))))
 (let ((?x151 (store ?x312 ?x263 (+ (select ?x312 ?x263) 1))))
 (= ?x151 ?x247)))))))))))))))))))))))))))
(assert
 (let (($x349 (and (= w__1 v__0) (= w__2 v__1) (= w__3 v__2) (= w__4 v__3) (= w__0 v__4))))
 (not $x349)))
(check-sat)
(exit)
