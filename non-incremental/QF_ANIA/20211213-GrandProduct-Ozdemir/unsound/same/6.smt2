
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status sat)
; benchmark generated from python API
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun w__3 () Int)
(declare-fun v__3 () Int)
(declare-fun w__4 () Int)
(declare-fun v__4 () Int)
(declare-fun w__5 () Int)
(declare-fun v__5 () Int)
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun start () (Array Int Int))
(assert
 (= v__0 w__0))
(assert
 (= v__1 w__1))
(assert
 (= v__2 w__2))
(assert
 (= v__3 w__3))
(assert
 (= v__4 w__4))
(assert
 (= v__5 w__5))
(assert
 (and (distinct b__0 b__1) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 6))
(assert
 (<= v__0 6))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 6))
(assert
 (<= v__1 6))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 6))
(assert
 (<= v__2 6))
(assert
 (>= w__3 0))
(assert
 (>= v__3 0))
(assert
 (<= w__3 6))
(assert
 (<= v__3 6))
(assert
 (>= w__4 0))
(assert
 (>= v__4 0))
(assert
 (<= w__4 6))
(assert
 (<= v__4 6))
(assert
 (>= w__5 0))
(assert
 (>= v__5 0))
(assert
 (<= w__5 6))
(assert
 (<= v__5 6))
(assert
 (let ((?x610 (* b__0 1)))
 (let ((?x267 (+ v__5 ?x610)))
 (let ((?x588 (* b__0 6)))
 (let ((?x310 (+ v__4 ?x588)))
 (let ((?x341 (* b__0 5)))
 (let ((?x328 (+ v__3 ?x341)))
 (let ((?x65 (* b__0 4)))
 (let ((?x395 (+ v__2 ?x65)))
 (let ((?x170 (* b__0 3)))
 (let ((?x426 (+ v__1 ?x170)))
 (let ((?x614 (* b__0 2)))
 (let ((?x615 (+ v__0 ?x614)))
 (let ((?x323 (store start ?x615 (+ (select start ?x615) 1))))
 (let ((?x344 (store ?x323 ?x426 (+ (select ?x323 ?x426) 1))))
 (let ((?x406 (store ?x344 ?x395 (+ (select ?x344 ?x395) 1))))
 (let ((?x501 (store ?x406 ?x328 (+ (select ?x406 ?x328) 1))))
 (let ((?x399 (store ?x501 ?x310 (+ (select ?x501 ?x310) 1))))
 (let ((?x108 (store ?x399 ?x267 (+ (select ?x399 ?x267) 1))))
 (let ((?x575 (+ w__5 ?x588)))
 (let ((?x502 (+ w__4 ?x341)))
 (let ((?x419 (+ w__3 ?x65)))
 (let ((?x227 (+ w__2 ?x170)))
 (let ((?x148 (+ w__1 ?x614)))
 (let ((?x611 (+ w__0 ?x610)))
 (let ((?x612 (store start ?x611 (+ (select start ?x611) 1))))
 (let ((?x186 (store ?x612 ?x148 (+ (select ?x612 ?x148) 1))))
 (let ((?x183 (store ?x186 ?x227 (+ (select ?x186 ?x227) 1))))
 (let ((?x616 (store ?x183 ?x419 (+ (select ?x183 ?x419) 1))))
 (let ((?x286 (store ?x616 ?x502 (+ (select ?x616 ?x502) 1))))
 (let ((?x20 (store ?x286 ?x575 (+ (select ?x286 ?x575) 1))))
 (= ?x20 ?x108))))))))))))))))))))))))))))))))
(assert
 (let ((?x366 (* b__1 1)))
 (let ((?x136 (+ v__5 ?x366)))
 (let ((?x160 (* b__1 6)))
 (let ((?x129 (+ v__4 ?x160)))
 (let ((?x34 (* b__1 5)))
 (let ((?x338 (+ v__3 ?x34)))
 (let ((?x237 (* b__1 4)))
 (let ((?x103 (+ v__2 ?x237)))
 (let ((?x321 (* b__1 3)))
 (let ((?x72 (+ v__1 ?x321)))
 (let ((?x163 (* b__1 2)))
 (let ((?x236 (+ v__0 ?x163)))
 (let ((?x288 (store start ?x236 (+ (select start ?x236) 1))))
 (let ((?x311 (store ?x288 ?x72 (+ (select ?x288 ?x72) 1))))
 (let ((?x78 (store ?x311 ?x103 (+ (select ?x311 ?x103) 1))))
 (let ((?x309 (store ?x78 ?x338 (+ (select ?x78 ?x338) 1))))
 (let ((?x31 (store ?x309 ?x129 (+ (select ?x309 ?x129) 1))))
 (let ((?x201 (store ?x31 ?x136 (+ (select ?x31 ?x136) 1))))
 (let ((?x210 (+ w__5 ?x160)))
 (let ((?x314 (+ w__4 ?x34)))
 (let ((?x187 (+ w__3 ?x237)))
 (let ((?x377 (+ w__2 ?x321)))
 (let ((?x313 (+ w__1 ?x163)))
 (let ((?x367 (+ w__0 ?x366)))
 (let ((?x262 (store start ?x367 (+ (select start ?x367) 1))))
 (let ((?x322 (store ?x262 ?x313 (+ (select ?x262 ?x313) 1))))
 (let ((?x273 (store ?x322 ?x377 (+ (select ?x322 ?x377) 1))))
 (let ((?x298 (store ?x273 ?x187 (+ (select ?x273 ?x187) 1))))
 (let ((?x159 (store ?x298 ?x314 (+ (select ?x298 ?x314) 1))))
 (let ((?x174 (store ?x159 ?x210 (+ (select ?x159 ?x210) 1))))
 (= ?x174 ?x201))))))))))))))))))))))))))))))))
(assert
 (let (($x540 (and (= w__1 v__0) (= w__2 v__1) (= w__3 v__2) (= w__4 v__3) (= w__5 v__4) (= w__0 v__5))))
 (not $x540)))
(check-sat)
(exit)
