
(set-info :smt-lib-version 2.6)
(set-logic QF_ANIA)
(set-info :source |
Generated by: Alex Ozdemir
Generated on: 2021-12-13
Generator: Z3Py API
Application: Soundness counterexamples for a cryptographic argument
Target solver: cvc5, Z3

# The special soundness of PLONK's grand product argument

Let F be a prime-order field and n a natural less than F's size. Let n = {1,
2, .., n} be a subset of F. The PLONK[1] grand product argument relies on the
fact that given a permutation pi: [n] -> [n] and functions A, B: [n] -> [n],

    prod_i (A(i) + beta * i + gamma) = prod_i (B(i) + beta * pi(i) + gamma)

holds for random beta, gamma in F with good probability only when A composed
with pi is B.

Does this implication hold in a deterministic setting, where the above is
checked for distinct---but non-random---beta and gamma?

If it is checked for n+1 distinct values of beta, and for each value of beta,
n+1 distinct values of gamma, then yes. One can prove this.

If it is checked for 2 distinct values of beta, and for each value of beta, n+1
distinct values of gamma, then no.

This series of benchmarks checks the implication holds
* for varying n
* for a fixed permutation pi = (2 3 ... n 1)
* for all A and B
  * that must be equal ("same") or may differ ("diff")
* for all distinct 2 ("unsound") or n+1 ("sound") beta values

rather than instantiating gamma explicitly, we just check that the multisets

    {{A[i] + beta * i}}_i  ==  {{B[i] + beta * pi(i)}}_i

are equal.

[1]: https://eprint.iacr.org/2019/953

|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "crafted")
(set-info :status sat)
; benchmark generated from python API
(declare-fun w__0 () Int)
(declare-fun v__0 () Int)
(declare-fun w__1 () Int)
(declare-fun v__1 () Int)
(declare-fun w__2 () Int)
(declare-fun v__2 () Int)
(declare-fun w__3 () Int)
(declare-fun v__3 () Int)
(declare-fun w__4 () Int)
(declare-fun v__4 () Int)
(declare-fun w__5 () Int)
(declare-fun v__5 () Int)
(declare-fun w__6 () Int)
(declare-fun v__6 () Int)
(declare-fun w__7 () Int)
(declare-fun v__7 () Int)
(declare-fun b__1 () Int)
(declare-fun b__0 () Int)
(declare-fun start () (Array Int Int))
(assert
 (= v__0 w__0))
(assert
 (= v__1 w__1))
(assert
 (= v__2 w__2))
(assert
 (= v__3 w__3))
(assert
 (= v__4 w__4))
(assert
 (= v__5 w__5))
(assert
 (= v__6 w__6))
(assert
 (= v__7 w__7))
(assert
 (and (distinct b__0 b__1) true))
(assert
 (>= w__0 0))
(assert
 (>= v__0 0))
(assert
 (<= w__0 8))
(assert
 (<= v__0 8))
(assert
 (>= w__1 0))
(assert
 (>= v__1 0))
(assert
 (<= w__1 8))
(assert
 (<= v__1 8))
(assert
 (>= w__2 0))
(assert
 (>= v__2 0))
(assert
 (<= w__2 8))
(assert
 (<= v__2 8))
(assert
 (>= w__3 0))
(assert
 (>= v__3 0))
(assert
 (<= w__3 8))
(assert
 (<= v__3 8))
(assert
 (>= w__4 0))
(assert
 (>= v__4 0))
(assert
 (<= w__4 8))
(assert
 (<= v__4 8))
(assert
 (>= w__5 0))
(assert
 (>= v__5 0))
(assert
 (<= w__5 8))
(assert
 (<= v__5 8))
(assert
 (>= w__6 0))
(assert
 (>= v__6 0))
(assert
 (<= w__6 8))
(assert
 (<= v__6 8))
(assert
 (>= w__7 0))
(assert
 (>= v__7 0))
(assert
 (<= w__7 8))
(assert
 (<= v__7 8))
(assert
 (let ((?x287 (* b__0 1)))
 (let ((?x1056 (+ v__7 ?x287)))
 (let ((?x970 (* b__0 8)))
 (let ((?x971 (+ v__6 ?x970)))
 (let ((?x147 (* b__0 7)))
 (let ((?x951 (+ v__5 ?x147)))
 (let ((?x295 (* b__0 6)))
 (let ((?x99 (+ v__4 ?x295)))
 (let ((?x975 (* b__0 5)))
 (let ((?x976 (+ v__3 ?x975)))
 (let ((?x956 (* b__0 4)))
 (let ((?x957 (+ v__2 ?x956)))
 (let ((?x259 (* b__0 3)))
 (let ((?x363 (+ v__1 ?x259)))
 (let ((?x109 (* b__0 2)))
 (let ((?x294 (+ v__0 ?x109)))
 (let ((?x24 (store start ?x294 (+ (select start ?x294) 1))))
 (let ((?x435 (store ?x24 ?x363 (+ (select ?x24 ?x363) 1))))
 (let ((?x965 (store ?x435 ?x957 (+ (select ?x435 ?x957) 1))))
 (let ((?x365 (store ?x965 ?x976 (+ (select ?x965 ?x976) 1))))
 (let ((?x112 (store ?x365 ?x99 (+ (select ?x365 ?x99) 1))))
 (let ((?x960 (store ?x112 ?x951 (+ (select ?x112 ?x951) 1))))
 (let ((?x139 (store ?x960 ?x971 (+ (select ?x960 ?x971) 1))))
 (let ((?x1068 (store ?x139 ?x1056 (+ (select ?x139 ?x1056) 1))))
 (let ((?x726 (+ w__7 ?x970)))
 (let ((?x961 (+ w__6 ?x147)))
 (let ((?x678 (+ w__5 ?x295)))
 (let ((?x728 (+ w__4 ?x975)))
 (let ((?x966 (+ w__3 ?x956)))
 (let ((?x175 (+ w__2 ?x259)))
 (let ((?x441 (+ w__1 ?x109)))
 (let ((?x705 (+ w__0 ?x287)))
 (let ((?x212 (store start ?x705 (+ (select start ?x705) 1))))
 (let ((?x180 (store ?x212 ?x441 (+ (select ?x212 ?x441) 1))))
 (let ((?x955 (store ?x180 ?x175 (+ (select ?x180 ?x175) 1))))
 (let ((?x974 (store ?x955 ?x966 (+ (select ?x955 ?x966) 1))))
 (let ((?x494 (store ?x974 ?x728 (+ (select ?x974 ?x728) 1))))
 (let ((?x413 (store ?x494 ?x678 (+ (select ?x494 ?x678) 1))))
 (let ((?x969 (store ?x413 ?x961 (+ (select ?x413 ?x961) 1))))
 (let ((?x1055 (store ?x969 ?x726 (+ (select ?x969 ?x726) 1))))
 (= ?x1055 ?x1068))))))))))))))))))))))))))))))))))))))))))
(assert
 (let ((?x683 (* b__1 1)))
 (let ((?x822 (+ v__7 ?x683)))
 (let ((?x924 (* b__1 8)))
 (let ((?x925 (+ v__6 ?x924)))
 (let ((?x763 (* b__1 7)))
 (let ((?x764 (+ v__5 ?x763)))
 (let ((?x142 (* b__1 6)))
 (let ((?x301 (+ v__4 ?x142)))
 (let ((?x921 (* b__1 5)))
 (let ((?x519 (+ v__3 ?x921)))
 (let ((?x746 (* b__1 4)))
 (let ((?x775 (+ v__2 ?x746)))
 (let ((?x671 (* b__1 3)))
 (let ((?x317 (+ v__1 ?x671)))
 (let ((?x547 (* b__1 2)))
 (let ((?x567 (+ v__0 ?x547)))
 (let ((?x401 (store start ?x567 (+ (select start ?x567) 1))))
 (let ((?x215 (store ?x401 ?x317 (+ (select ?x401 ?x317) 1))))
 (let ((?x784 (store ?x215 ?x775 (+ (select ?x215 ?x775) 1))))
 (let ((?x119 (store ?x784 ?x519 (+ (select ?x784 ?x519) 1))))
 (let ((?x315 (store ?x119 ?x301 (+ (select ?x119 ?x301) 1))))
 (let ((?x634 (store ?x315 ?x764 (+ (select ?x315 ?x764) 1))))
 (let ((?x146 (store ?x634 ?x925 (+ (select ?x634 ?x925) 1))))
 (let ((?x122 (store ?x146 ?x822 (+ (select ?x146 ?x822) 1))))
 (let ((?x479 (+ w__7 ?x924)))
 (let ((?x916 (+ w__6 ?x763)))
 (let ((?x777 (+ w__5 ?x142)))
 (let ((?x651 (+ w__4 ?x921)))
 (let ((?x641 (+ w__3 ?x746)))
 (let ((?x780 (+ w__2 ?x671)))
 (let ((?x515 (+ w__1 ?x547)))
 (let ((?x682 (+ w__0 ?x683)))
 (let ((?x360 (store start ?x682 (+ (select start ?x682) 1))))
 (let ((?x284 (store ?x360 ?x515 (+ (select ?x360 ?x515) 1))))
 (let ((?x745 (store ?x284 ?x780 (+ (select ?x284 ?x780) 1))))
 (let ((?x920 (store ?x745 ?x641 (+ (select ?x745 ?x641) 1))))
 (let ((?x410 (store ?x920 ?x651 (+ (select ?x920 ?x651) 1))))
 (let ((?x757 (store ?x410 ?x777 (+ (select ?x410 ?x777) 1))))
 (let ((?x923 (store ?x757 ?x916 (+ (select ?x757 ?x916) 1))))
 (let ((?x282 (store ?x923 ?x479 (+ (select ?x923 ?x479) 1))))
 (= ?x282 ?x122))))))))))))))))))))))))))))))))))))))))))
(assert
 (let (($x743 (and (= w__1 v__0) (= w__2 v__1) (= w__3 v__2) (= w__4 v__3) (= w__5 v__4) (= w__6 v__5) (= w__7 v__6) (= w__0 v__7))))
 (not $x743)))
(check-sat)
(exit)
